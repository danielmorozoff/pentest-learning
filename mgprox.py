#!/usr/bin/python

import sys
import os
import subprocess
import traceback
import socket
import threading
import signal


def loop(l_host, l_port, r_host, r_port, receive_first):

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        print '[*] Attempting to bind %s:%d ' % (l_host, l_port)
        server.bind((l_host, l_port))
    except Exception as er:

        print "[!!] Exception binding to %s:%d" % (l_host, l_port)
        print str(er)
        print(traceback.format_exc())
        sys.exit(0)

    print "[!!] Listening to %s:%d" % (l_host, l_port)
    server.listen(5)

    while True:
        cli_soc, addr = server.accept()
        print "[==>] Received connnection from  %s:%d" % (addr[0], addr[1])

        prox_thread = threading.Thread(
            target=proxy_handle, args=(cli_soc, r_host, r_port, receive_first))
        prox_thread.start()


def proxy_handle(cli_soc, r_host, r_port, receive_first):

    r_soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("[*] Attempting connection to %s:%d" % (r_host, r_port))
    r_soc.connect((r_host, r_port))

    # If receive data true -- parse data that comes in then establish con
    if receive_first:
        r_buff = receive_from(r_soc)
        hexdump(r_buff)

        r_buff = response_handle(r_buff)
        if(len(r_buff)):
            print "[<==] Sending %d bytes local" % len(r_buff)
            cli_soc.send(r_buff)

    while True:

        l_buff = receive_from(cli_soc)

        if len(l_buff):
            print "[==>] Received %d bytes from local" % (len(l_buff))
            hexdump(l_buff)

            l_buff = request_handle(l_buff)

            r_soc.send(l_buff)
            print "[==>] Sent to remote"
        r_buff = receive_from(r_soc)

        if len(r_buff):
            print "[<==] Received %d bytes from remote" % (len(l_buff))
            hexdump(r_buff)

            r_buff = response_handle(r_buff)

            cli_soc.send(r_buff)

            print "[<==] Sent to local"

        if not len(l_buff) or not len(r_buff):
            cli_soc.close()
            r_soc.close()
            print "[*] No more data. Closing connection"
            break


def hexdump(src, leng=16):
    result = []
    digits = 4 if isinstance(src, unicode) else 2
    for i in xrange(0, len(src), leng):
        s = src[i:i + leng]
        hexa = b' '.join(["%o*X" % (digits, ord(x)) for x in s])
        text = b''.join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
        result.append(b"%04X %-*s %s" % (i, leng * (digits + 1), hexa, text))
    print b'\n'.join(result)


def receive_from(conn):
    buffer = ""
    # conn.settimeout(2)
    try:
        while True:
            data = conn.recv(4096)
            if not data:
                break
            buffer += data
    except:
        print "[!!] Exception in receiving"
        pass
    return buffer

# Request going to remote -- change if needed


def request_handle(buffer):
    print ('[*]Req handle')
    return buffer

# Reponse going to local


def response_handle(buffer):
    print ('[*]Resp handle')
    return buffer


def kill_server(l_host, l_port):
    print 'Killing main server process'
    com = 'lsof -i'
    try:
        out = subprocess.check_output(
            com, stderr=subprocess.STDOUT, shell=True)
    except:
        out = 'Failed execution. \r\n'

    print 'Searching for %s: ' % (l_host + ':' + str(l_port))
    for line in out.splitlines():
        if (l_host + ':' + str(l_port)) in line:
            pid = line.split('    ')[1].split(' ')[0]
            print 'killing: %s' % pid
            os.kill(int(pid), signal.SIGKILL)


def main():

    l_host = sys.argv[1]
    l_port = int(sys.argv[2])

    r_host = sys.argv[3]
    r_port = int(sys.argv[4])

    receive_first = sys.argv[5]

    if receive_first == "True":
        receive_first = True
    else:
        receive_first = False
    try:
        loop(l_host, l_port, r_host, r_port, receive_first)
    except:
        print 'Killing server...'
        kill_server(l_host, l_port)
main()
